#####################################################################################################################
public Num calculateSequence(Expression sequence) {
	List<Operation> tmpStack = new Stack<>();
        Expressible num, op; //Número auxiliar para leer números de la secuencia.
	List<Operation> operations = sequence.getOperations();
        List<Num> operands = new LinkedList<>();
        operations = sequence.getOperands();

	while(!operations.isEmpty()){
        op = operations.poll();
        while (op.compare(op.peek()) ->(a > b) && op.peek() != null){
            op.pushOperand(operands.poll());
            tmpStack.push(op);
            op = operations.poll();
        }
        num = operands.poll();
        for (i = 1; i <= sequence.getNumParams(); i++) {
            op.pushOperand(num);
            num = operands.poll();
        }

        tmpStack.push(op);
        num = this.calculateStack(tmpStack);
	if(!operations.isEmpty()){
		operands.offerFirst(num);
	}
     }
	return num;
}
###############################################################################################################
public BigDecimal calculateStack(Stack<Operation> stack) throws Exception{
	//Preconditions
	if(stack.isEmpty){
		throw new Exception("La pila no puede estar vacía");
	}else if(!stack.peek().isCalculable()){
		throw new Exception("El primer elemento de la pila debe ser calculable");
	}else if(stack.size() < 2){
		throw new Exception ("La pila debe tener como mínimo dos operacions");
	}

	Num num = stack.pop().getTotal();
	Operation op;
	while(!stack.isEmpty()){
		op = stack.pop().pushOperand(num);
		num = op.getTotal();
	}
	return num.getValue();
}
################################################################################################################
public Stack<Expression> organizeParens(Expression exp){
	//Preconditions
	if(exp.getExpression().isEmpty){
		throw new Exception("La lista de expresiones no puede estar vacía");
	}
	List<Expressible> eTmp = new ArrayList<>(exp.getExpression());
	List<Parenthesis> parens = new LinkedList<>();
	for(Expresible e : eTmp){
		if(e instanceof Paramethers){
			parens.push(e);
		}
	}
	Map<Parenthesis, Parenthesis> mapParens = getMapParenthesis();
	if(mapParens == null){
		throw new Exception("Los paréntesis no están bien colocados");
	}
	List<Expression> expressions = new Stack<>();
	int indexOpener, indexCloser;
	Exression e;
	for(Map.Entry<Parenthesis, Parenthesis> entry : mapParens.entrySet()){
		indexOpener = eTmp.indexOf(entry.getKey()) + 1;
		indexOpener = eTmp.indexOf(entry.getValue());
		for(int i = indexOpener, i < indexOpener, i++){
			e = new Expression();
			e.add(eTmp.get(i));
		}
		expressions.push(e);
	}
	return expressions;	
}
#################################################################################################################
public Map<Parenthesis,Parenthesis> getMapParenthesis(LinkedList<Parenthesis> parens){
	//Preconditions
	if(parens.isEmpty){
		throw new Exception("La lista no debe estar vacía");
	}
	
	Map<Parentesis, Parentesis> complementarios = new HashMap<>();
        Stack<Parentesis> pila = new Stack<>();

        for (Parentesis parentesis : lista) {
            if (parentesis.esApertura()) {
                pila.push(parentesis);
            } else if (parentesis.esCierre()) {
                if (!pila.empty()) {
                    Parentesis apertura = pila.pop();
                    complementarios.put(apertura, parentesis);
                }
            }
        }

        return complementarios;	
}